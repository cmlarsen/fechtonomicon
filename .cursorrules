# Code Quality and Hygiene Rules

## Zero Tolerance Policy
- **ABSOLUTE RULE**: Never ignore, suppress, or disable Biome or TypeScript errors and warnings
- Do not use `// biome-ignore`, `// @ts-ignore`, `// @ts-expect-error`, `// eslint-disable`, or any other suppression comments
- Do not disable rules in biome.json or tsconfig.json to work around errors
- All errors and warnings must be fixed properly by addressing the root cause
- If an error seems unfixable, discuss alternatives rather than suppressing it

## Pre-Commit Validation
- **CRITICAL**: Before committing, always run `yarn validate` to ensure all checks pass
- The validate script runs: formatting check, linting, and type checking
- Use `yarn validate:fix` to automatically fix formatting and linting issues
- Never commit code that fails validation - fix issues first
- **CRITICAL**: All tests must pass before committing (use `yarn test:ci`)

## Linting Requirements
- **CRITICAL**: Before completing any task, you MUST run the linter to check for errors
- Use `yarn lint` or `biome lint .` to check for linting errors
- If linting errors are found, fix them before marking the task as complete
- Never commit or complete work with linting errors present
- Both errors AND warnings must be addressed - no exceptions

## TypeScript Requirements
- **CRITICAL**: After every change, you MUST run the TypeScript compiler to check for type errors
- Use `yarn typecheck` or `tsc --noEmit` to check for TypeScript errors
- Use `yarn typecheck:watch` for continuous type checking in watch mode
- Use `yarn typecheck:verbose` for formatted, colorized error output
- Use `./scripts/check-types.sh` for enhanced error reporting with summary
- If TypeScript errors are found, fix them before marking the task as complete
- Never commit or complete work with TypeScript errors present
- TypeScript strict mode is enabled - ensure all types are properly defined
- Both errors AND warnings must be addressed - no exceptions

## Formatting and Import Sorting
- All code must be formatted using Biome (configured in biome.json)
- Biome is set as the default formatter in VS Code settings
- Import sorting and organization is handled automatically by Biome
- Format on save is enabled - ensure all code follows Biome's formatting rules

## Code Style
- Follow the Biome configuration in biome.json:
  - 2 spaces indentation
  - Single quotes for strings
  - Double quotes for JSX attributes
  - Semicolons always
  - ES5 trailing commas
  - Line width: 100 characters
  - LF line endings

## Code Quality Best Practices
- **No unused variables, imports, or function parameters** - All must be removed or used
- **No array index keys** - Use stable, unique identifiers instead
- **No non-null assertions** - Handle null/undefined cases properly
- **No assignments in expressions** - Keep assignments separate from expressions
- **Use const** - Prefer const over let, avoid var entirely
- **Use template literals** - Prefer template strings over string concatenation
- **Avoid excessive complexity** - Keep functions simple and focused
- **Proper error handling** - Handle errors explicitly, don't silently fail

## Quality Checks
- Run `yarn validate` to run all checks (formatting, linting, type checking)
- Run `yarn validate:fix` to automatically fix formatting and linting issues
- Run `yarn check` or `biome check .` to verify formatting and linting
- Use `yarn check:fix` or `biome check --apply .` to automatically fix issues
- Always ensure code passes all linting checks before task completion
- TypeScript Checking Commands:
  - `yarn typecheck` - Run once and exit
  - `yarn typecheck:watch` - Watch mode for continuous checking
  - `yarn typecheck:verbose` - Pretty-formatted output with colors
  - `./scripts/check-types.sh` - Enhanced output with summary
- Always ensure code passes all TypeScript checks before task completion

## Testing Requirements
- **CRITICAL**: All tests must pass before completing any task
- **IMPORTANT**: Use `yarn test:ci` to run tests as a one-shot (non-watch mode)
- **WARNING**: `yarn test` runs in watch mode and will keep running - use `yarn test:ci` for one-shot test runs
- Use `yarn test` for watch mode during development (only when you want continuous testing)
- If a test fails, fix it before marking the task as complete
- **Exception**: Tests may be updated or removed only when deliberately changing the core functionality that the test covers
- When updating tests due to functionality changes, ensure the new tests accurately reflect the new behavior
- Write tests for new functionality when appropriate
- Ensure existing tests pass before completing tasks

## Git Workflow
- Always run `yarn validate` before committing
- Commit messages should be clear and descriptive
- Keep commits focused - one logical change per commit
- Ensure CI checks pass before merging PRs

## Metro and Babel Configuration
- **CRITICAL**: Changes to `metro.config.js`, `metro.transformer.js`, or `babel.config.js` are high-risk and can break the app
- **ABSOLUTE RULE**: When creating or modifying `metro.transformer.js`, ALWAYS delegate non-handled files to `@expo/metro-config/babel-transformer` (NOT `metro-babel-transformer`)
- **CRITICAL**: After ANY changes to Metro or Babel configuration, test on ALL platforms (iOS, Android, and web) before committing
- **REQUIRED**: When fixing platform-specific bundling issues (e.g., web `import.meta` errors), ensure the fix doesn't break other platforms
- **Example of correct metro.transformer.js pattern**:
  ```javascript
  module.exports.transform = async ({ src, filename, options }) => {
    if (filename.endsWith('.svg')) {
      return customTransformer.transform({ src, filename, options });
    }
    // ALWAYS delegate to Expo transformer for React Native polyfills
    const expoTransformer = require('@expo/metro-config/babel-transformer');
    return expoTransformer.transform({ src, filename, options });
  };
  ```
- Never use `metro-babel-transformer` directly - it lacks React Native polyfills (like `require`) that Expo provides
- Clear Metro cache after configuration changes: `yarn start --clear`
- If bundling errors occur after config changes, check that the transformer chain is correct

## Design and UI Components
- **CRITICAL**: Our design aesthetic is **cozy medieval manuscript** with a **delightful modern UX**
- **ALWAYS use existing button components** when creating new components that need buttons:
  - Use `PrimaryButton` from `src/components/buttons` for primary actions (gold theme)
  - Use `SecondaryButton` from `src/components/buttons` for secondary actions (parchment/burgundy variants)
  - Use `IconButton` from `src/components/buttons` for circular icon buttons
- Do not create new button styles or components - reuse the existing button suite
- When designing new UI components, maintain consistency with the medieval manuscript aesthetic:
  - Use colors from `src/theme/tokens.ts` (parchment, gold, iron, burgundy, green)
  - Use fonts from the theme tokens (CormorantGaramond for body, Texturina for titles)
  - Apply appropriate shadows and borders that match the existing design language
  - Ensure components feel both cozy/medieval and delightfully modern in UX
- Reference existing components in `src/components/` for design patterns and styling consistency
